/*
 ******************************************************************************
 ******************************************************************************
%MS_COPYRIGHT%
This file must not be copied or distributed, in part or entirety, in any form
without prior written consent from:
%MS_ADDRESS_LONG1%
%MS_ADDRESS_LONG2%
%MS_ADDRESS_LONG3%
%MS_ADDRESS_LONG4%
%MS_WEB%
 ******************************************************************************
File Information
================
%PID% %PRT% %PO%

%PM% - %PD%
 *****************************************************************************
 ******************************************************************************
 */

package com.slepeweb.sandbox.acm.mvc;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.mediasurface.client.IHost;
import com.mediasurface.client.IItem;
import com.mediasurface.client.ISite;
import com.mediasurface.client.IType;
import com.mediasurface.client.IView;
import com.mediasurface.client.Mediasurface;
import com.mediasurface.client.cmc.Utils;
import com.mediasurface.client.servlets.DispatcherManager;
import com.mediasurface.client.servlets.IAttributeNames;
import com.mediasurface.client.servlets.IDispatcher;
import com.mediasurface.client.servlets.NameEncoder;
import com.mediasurface.client.taglib.IChainedException;
import com.mediasurface.client.taglib.MaeUtils;
import com.mediasurface.client.taglib.SessionTimeoutHandler;
import com.mediasurface.datatypes.HostKey;
import com.mediasurface.datatypes.ItemKey;
import com.mediasurface.datatypes.SecurityContextHandle;
import com.mediasurface.general.AuthorizationException;
import com.mediasurface.general.Base64;
import com.mediasurface.general.ContainedLinkResourceException;
import com.mediasurface.general.IProductModule;
import com.mediasurface.general.ResourceException;
import com.mediasurface.general.SecurityContextNotFoundException;
import com.mediasurface.general.SerializableObjectCache;

/**
 * Maps requested URL onto an ACM item and forward request to a location based on that item's type and view. The item
 * and type are put into the request context for use by JSP pages. The {@link Mediasurface} instance and optional
 * {@link SecurityContextHandle} are also put into the request context.
 * 
 * <p>
 * The servlet should be mapped to the root web application with url pattern <code>/</code>. Mapping anywhere else will
 * result in returned pages having incorrect hyperlinks. The request host name, port number, path and version parameter
 * are mapped straight onto the item URL. For instance the request URL <http://www.alterian.com> is mapped to the item
 * with URL <http://www.alterian.com>
 * 
 * <p>
 * The view is extracted as request parameter with name "<code>view</code>". It is not checked that this is a valid
 * view. If no view is specified then the default for the item's site is used.
 * 
 * <p>
 * If not already present, a Mediasurface object is placed into the servlet context as an attribute with name "
 * <code>ms</code>". A {@link SecurityContextHandle} attribute with name "<code>ctx</code>" is searched for within the
 * Servlet's session. If not present in the session, HTTP <code>Basic</code> authentication is used to attempt to log
 * into ACM. The {@link SecurityContextHandle} from a successful login is placed as an attribute into the session with
 * name "<code>ctx</code>" If basic authentication fails it is silently ignored, typically causing an
 * {@link AuthorizationException} later on and hence a further request to authenticate. If no handle is present the
 * public user is assumed. Assuming a {@link SecurityContextHandle} is created or found, it is put into the request
 * context under the name "ctx". These objects are used by this servlet to map the request URL to an item, and by the
 * JSP taglib where needed.
 * 
 * <p>
 * If the item is not found, an "<code>HTTP 404 Not Found</code>" status is returned. The same response is generated by
 * the request dispatcher if the required template does not exist. The web application may intercept the error, as
 * detailed below.
 * 
 * 
 * <p>
 * Unauthorized access is responded to by returning an "<code>HTTP 401 Unauthorised</code>" status. The response also
 * includes a challenge to authenticate for the realm specified by the <code>authenticate-realm</code> servlet
 * initialization parameter using <code>Basic</code> authentication. This challenge is supressed if there already exists
 * a {@link SecurityContextHandle} on the session. Typically a browser will show a login dialog then attempt to reload
 * the page. An access is considered unauthorized if {@link AuthorizationException} is
 * <ul>
 * <li>thrown whilst retrieving the item details,
 * <li>the root cause of a Servlet exception thrown by the forwarded page or
 * <li>the root cause of a JspTagException that is itself the root cause of a Servlet exception thrown by the forwarded
 * page.
 * </ul>
 * 
 * <p>
 * The servlet path forwarded to is derived from the items binary property, the type name and the view specified in the
 * request.
 * 
 * <p>
 * The retrieved {@link IItem} corresponding to the URL into the request context as an attribute with name "
 * <code>requestItem</code>". The retrieved {@link IType} corresponding to the type of the item referred to by the URL
 * into the request context as an attribute with name "<code>requestType</code>".
 * 
 * <p>
 * To configure the servlet add definition to your web applications web.xml file similar to:
 * 
 * <pre>
 * &lt;servlet&gt;
 *     &lt;servlet-name&gt;MediasurfaceController&lt;/servlet-name&gt;
 *     &lt;servlet-class&gt;com.mediasurface.client.servlets.MediasurfaceControllerServlet&lt;/servlet-class&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;mediasurface-url&lt;/param-name&gt;
 *       &lt;param-value&gt;//localhost/&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;authenticate-realm&lt;/param-name&gt;
 *       &lt;param-value&gt;Personalization&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;default-binary-servlet-name&lt;/param-name&gt;
 *       &lt;param-value&gt;Stream&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;template-base&lt;/param-name&gt;
 *       &lt;param-value&gt;/mytemplates/&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;template-separator&lt;/param-name&gt;
 *       &lt;param-value&gt;/&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;template-extension&lt;/param-name&gt;
 *       &lt;param-value&gt;.jsp&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;template-group-separator&lt;/param-name&gt;
 *       &lt;param-value&gt;#&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;logging&lt;/param-name&gt;
 *       &lt;param-value&gt;false&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;use-container-context-factory&lt;/param-name&gt;
 *       &lt;param-value&gt;false&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;defaultLocale&lt;/param-name&gt;
 *       &lt;param-value&gt;en,UK&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;init-param&gt;
 *       &lt;param-name&gt;bypass-url-stem&lt;/param-name&gt;
 *       &lt;param-value&gt;&lt;/param-value&gt;
 *     &lt;/init-param&gt;
 *     &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!-- Priority 1 --&gt;
 *   &lt;/servlet&gt;
 * </pre>
 * 
 * <p>
 * The <code>mediasurface-url</code> initialisation parameter is the URL of the CAe server with which to connect. The
 * default value is <code>//localhost/Mediasurface</code>.
 * <p>
 * The <code>authenticate-realm</code> initialisation parameter is the name of the Realm used for HTTP
 * <code>Basic</code> authentication. The default value is <code>Mediasurface</code>.
 * <p>
 * The <code>default-binary-servlet-name</code> initialisation parameter is the name of the servlet used to forward
 * requests for standard views of binary items to. If not present these items are treated no differently than any other.
 * 
 * <p>
 * <code>template-base</code>, <code>template-separator</code> and <code>template-extension</code> are used to specify
 * the location to forward requests items not dealt with by the default binary servlet. The forwarding location is of
 * the form: <code>template-base</code><var>&lt;type-name&gt;</var><code>template-separator</code
 *     ><var>&lt;view-name&gt;</var>
 * <code>template-extension</code>. The type and view names have characters other than alphanumeric US ASCII replaced by
 * underscores. In particular spaces and symbols are replaced.
 * <p>
 * The default initialisation parameter values for template forwarding are:
 * <table border="0">
 * <tr>
 * <th>Parameter</th>
 * <th>Value</th>
 * </tr>
 * <tr>
 * <td>template-base</td>
 * <td><code>/WEB-INF/templates/</code></td>
 * </tr>
 * <tr>
 * <td>template-separator</td>
 * <td><code>/</code></td>
 * </tr>
 * <tr>
 * <td>template-extension</td>
 * <td><code>.jsp</code></td>
 * </tr>
 * <tr>
 * <td>template-group-separator</td>
 * <td><code>#</code></td>
 * </tr>
 * </table>
 * <p>
 * For instance an item of type "<code>Genre: Rap</code>" with view "<code>WAPDelivery</code>", and using group
 * <code>editor</code> is mapped by default to location
 * <code>/WEB-INF/templates/Genre__Rap/editor-WAPDelivery.jsp</code>.
 * 
 * <p>
 * The <code>logging</code> initialisation parameter sets whether to output a trace of how each request is handled to
 * the servlet log. Valid values are <code>true</code> and <code>false</code>. Enabling logging can help with setting up
 * the servlet or finding a specific problem, but it will slow down requests and so should not be left enabled in a
 * production environment.
 * 
 * <p>
 * The <code>use-container-context-factory</code> initialisation parameter is set to true if the container's setting for
 * the java.naming.factory.initial property is to be used when locating the CAe's services. The default for this
 * parameter is false. The only time that one would want to set this to true is if the CAe is itself contained by the
 * same container.
 * 
 * <p>
 * The <code>defaultLocale</code> initialisation parameter is set if the default locale of the current JVM wants to be
 * set when this web application starts up. This may be useful when localising the content management console to enable
 * different message files to be picked up. It shoule be noted, however, that this parameter will alter the default
 * locale for the entire Virtual Machine and may have unforseen consquences in other web applications. If this parameter
 * is not set, the locale is not altered from it's startup default. There are two formats with which this vcalue can be
 * entered
 * <ul>
 * <li>&lt;param-value&gt;language, country&lt;/param-value&gt;
 * <li>&lt;param-value&gt;language, country, variant&lt;/param-value&gt;
 * </ul>
 * Please see the javadoc for java.util.Locale for more details.
 * 
 * <p>
 * The <code>bypass-url-stem</code> is way of asking this servlet to pass all requests starting with the specified url
 * to be passed directly to the default servlet without first checking their availability via the CAe. This allows
 * static directories to be served out much more easily than using the servlet mapping element. The default is no
 * bypassing. This element may contain multiple comma separated urls.
 * 
 * 
 * <p>
 * If you wish this server to return URLs that are based on a Local Host name rather than a Public Host name, then set
 * the <code>server-name</code> and <code>server-port</code> initialisation parameters to identify the Content Server
 * entry in ACM through which the mappings are to be made. For example, a Public Host name of www.mycompany.com may be
 * mapped to a Local Host name of staging.mycompany.com through a Content Server named "Staging Server" listening on
 * port 8080. In this case specify "Staging Server" as the value of the <code>server-name</code> parameter, and "8080"
 * as the value for <code>server-port</code>.
 * 
 * <p>
 * The <code>forward-to-default-if-not-found</code> and <code>default-servlet-name</code> parameters are used to specify
 * a default servlet to forward requests to, if the URL requested does not match an item in the repository.
 * 
 * <p>
 * To make this servlet the default for a web application, add the following to the web.xml:
 * 
 * <pre>
 * &lt;servlet-mapping&gt;
 *     &lt;servlet-name&gt;MediasurfaceController&lt;/servlet-name&gt;
 *     &lt;url-pattern&gt;/&lt;/url-pattern&gt;
 *   &lt;/servlet-mapping&gt;
 * </pre>
 * 
 * <p>
 * It may be useful to map some of the request to specific servlets or JSPs. For instance:
 * 
 * <pre>
 * &lt;servlet-mapping&gt;
 *     &lt;servlet-name&gt;PDFRenderServlet&lt;/servlet-name&gt;
 *     &lt;url-pattern&gt;/WEB-INF/templates/ApplicationForm/PDF.jsp&lt;/url-pattern&gt;
 *   &lt;/servlet-mapping&gt;
 * </pre>
 * 
 * <p>
 * Request for missing item may be intercepted by adding to the web.xml.
 * 
 * <pre>
 * &lt;error-page&gt;
 *      &lt;error-code&gt;404&lt;/error-code&gt;
 *      &lt;location&gt;/notfound&lt;/location&gt;
 *    &lt;/error-page&gt;
 * </pre>
 * 
 * <p>
 * Request for unauthorized item may be intercepted by adding to the web.xml. For instance the new location may supply a
 * login form to place a {@link SecurityContextHandle} in the session with name "<code>ctx</code>".
 * 
 * <pre>
 * &lt;error-page&gt;
 *      &lt;error-code&gt;401&lt;/error-code&gt;
 *      &lt;location&gt;/login.jsp&lt;/location&gt;
 *    &lt;/error-page&gt;
 * </pre>
 * 
 * @author Thomas Hawtin
 */
@SuppressWarnings("serial")
public class MediasurfaceControllerServlet extends javax.servlet.http.HttpServlet {
	private static final String VIEW_WEB_ANALYTICS_PARAM = "view-web-analytics";
	private static final String TOKEN_PARAM = "token";

	/**
	 * The view number request parameter.
	 */
	private static final String VIEW_PARAM = IAttributeNames.MODEL_VIEW_PARAM;

	/**
	 * The version number request parameter.
	 */
	private static final String VERSION_PARAM = IAttributeNames.MODEL_VERSION_PARAM;

	/**
	 * The template id param
	 */
	private static final String TEMPLATE_ID_PARAM = IAttributeNames.TEMPLATE_ID_PARAM;

	/**
	 * The group request parameter.
	 */
	private static final String GROUP_PARAM = IAttributeNames.MODEL_GROUP_PARAM;

	/**
	 * Whether or not running inside an ATG Dynamo VM - in fact, whether we have access to the class
	 * atg.servlet.DynamoHttpServletRequest
	 */
	private static final boolean IN_DYNAMO;

	/**
	 * Base for templates.
	 */
	private String templateBase;

	/**
	 * Separator for templates.
	 */
	private String templateSeparator;

	/**
	 * Extension for templates.
	 */
	private String templateExtension;

	/**
	 * Group / view separator for templates
	 */
	private String templateGroupSeparator;

	/**
	 * The character encoding for all request coming into the Servlet
	 */
	private String requestEncoding;

	/**
	 * The URL stems to bypass
	 */
	private String[] bypassStems;

	/**
	 * Whether to output logging information for each request to the servlet log.
	 */
	private boolean logging;

	/**
	 * Realm used for HTTP Basic authentication. Defaults to "Mediasurface".
	 */
	private String authenticateRealm;

	/**
	 * Whether to forward requests to the default servlet if the item is not found in ACM.
	 */
	private boolean forwardToDefaultServlet;

	/**
	 * Cached default view name for this site.
	 **/
	private String defaultViewName;

	/**
	 * Default ContentReferenceRenderer type name for this site.
	 **/
	private String ContentReferenceObjectTypeName;

	/**
	 * Default Template Referrer type name for this site.
	 **/
	private String templateRefTypeName;

	private static final int REQUESTS_BETWEEN_VIEW_RELOADS = 40;

	/**
	 * Number of requests left to service before default view name should be rechecked.
	 **/
	private int requestsLeftBeforeViewReload = 0;

	/**
	 * The dispatch manager that will control any calls to {@link IDispatchers}.
	 **/
	private DispatcherManager m_dispatchManager;

	/**
	 * The set of names of types that are subclasses of the default ContentReference Object Type
	 */
	@SuppressWarnings("rawtypes")
	private Hashtable currentContentReferenceObjectTypes;

	/**
	 * The field name in which the physical rendering template URL is stored
	 */
	private String presentationTemplateFieldName;

	/**
	 * 
	 Theare held
	 */
	private SerializableObjectCache viewToTemplateMapCache;

	/**
	 * The cache object which holds the template reference objects to thier corresponding physical rendering template
	 * (URL to jsp)
	 */
	private SerializableObjectCache renderingTemplateReferenceCache;

	/**
	 * Specified size of the "view name to view key id's" cache
	 */
	private int viewNameToIDCacheSize;

	/**
	 * A Map object that holds each sites "view name to view key id's" cache. There will be one entry maintained for
	 * each site that is serviced from this MediasurfaceControllerServlet instance.
	 */
	@SuppressWarnings("rawtypes")
	private Map allViewNameCaches;

	private final String OLD_STYLE_TEMPLATE = "4.7_style_processing";

	/**
	 * Set to true if the API should be initialised so that it uses the container-specified JNDI context factory class
	 * to locate the CAe rather than the default RMI Registry service.
	 **/
	private boolean useContainerContextFactory = false;

	private String binaryServletName;

	private String defaultServletName;

	private final Map<HostKey, String> wjTokens = new HashMap<HostKey, String>();

	static {
		boolean dynamo = true;
		try {
			Class.forName("atg.servlet.DynamoHttpServletRequest");
		} catch (ClassNotFoundException e) {
			dynamo = false;
		}
		IN_DYNAMO = dynamo;
	}

	/**
	 * Read init parameters.
	 */
	/* Method public in superclass, for some reason. */
	@Override
	@SuppressWarnings("rawtypes")
	public void init() throws ServletException {
		Mediasurface ms = null;

		authenticateRealm = getInitParameter("authenticate-realm", "Mediasurface");
		getServletContext().setAttribute(IAttributeNames.APP_AUTHENTICATE_REALM, authenticateRealm);

		// Export the initial parameters to the application scope so other servlets can see them
		templateBase = getInitParameter("template-base", "/WEB-INF/templates/");
		getServletContext().setAttribute(IAttributeNames.APP_BASE_DIRECTORY, templateBase);

		templateSeparator = getInitParameter("template-separator", "/");
		getServletContext().setAttribute(IAttributeNames.APP_TEMPLATE_SEPARATOR, templateSeparator);

		ContentReferenceObjectTypeName = getInitParameter("ContentReference-object-type-name", "ContentReference");

		getServletContext().setAttribute(IAttributeNames.APP_CONTENT_REFERENCE_OBJECT_TYPE_NAME,
				ContentReferenceObjectTypeName);

		// Add this first entry to the currentContentReferenceObjectTypes
		currentContentReferenceObjectTypes = new Hashtable();
		currentContentReferenceObjectTypes.put(ContentReferenceObjectTypeName, "member");

		templateRefTypeName = getInitParameter("template-referrer-type-name", "TemplateRef");

		getServletContext().setAttribute(IAttributeNames.APP_TEMPLATE_REF_TYPE_NAME, templateRefTypeName);

		// No longer required as of 10/10/03 - change to use template Key/Resource pairs
		/*
		 * viewTakesPrecedence = (getInitParameter("view-takes-precedence", "false").equals("true") ? true : false);
		 * getServletContext().setAttribute( IAttributeNames.APP_VIEW_TAKES_PRECEDENCE, viewTakesPrecedence ? "true" :
		 * "false");
		 */

		// Initialize the two caches used in the ContentReference + template reference process
		int size = Integer.parseInt(getInitParameter("view-to-template-map-cache-size", "10"));

		if (size > 0)
			viewToTemplateMapCache = new SerializableObjectCache(size);
		else
			viewToTemplateMapCache = null;

		size = Integer.parseInt(getInitParameter("physical-template-reference-cache-size", "10"));

		if (size > 0)
			renderingTemplateReferenceCache = new SerializableObjectCache(size);
		else
			renderingTemplateReferenceCache = null;

		viewNameToIDCacheSize = Integer.parseInt(getInitParameter("view-name-to-id-cache-size", "20"));

		// Need to initilaize the allViewNameCaches Set
		allViewNameCaches = Collections.synchronizedMap(new HashMap());

		// The default value for the TemplateRecord types presentation template field
		presentationTemplateFieldName = getInitParameter("presentation-template-field-name", "templateRef");

		getServletContext().setAttribute(IAttributeNames.APP_PRESENTATION_TEMPLATE_FIELD_NAME,
				presentationTemplateFieldName);

		templateExtension = getInitParameter("template-extension", ".jsp");
		getServletContext().setAttribute(IAttributeNames.APP_TEMPLATE_EXTENSION, templateExtension);

		templateGroupSeparator = getInitParameter("template-group-separator", "#");
		getServletContext().setAttribute(IAttributeNames.APP_TEMPLATE_GROUP_SEPARATOR, templateGroupSeparator);

		requestEncoding = getInitParameter("request-encoding", null);
		if (requestEncoding != null) {
			getServletContext().setAttribute(IAttributeNames.REQUEST_CHARACTER_ENCODING, requestEncoding);
		}

		logging = Boolean.valueOf(getInitParameter("logging", "false")).booleanValue();

		useContainerContextFactory = Boolean.valueOf(getInitParameter("use-container-context-factory", "false"))
				.booleanValue();
		getServletContext().setAttribute(IAttributeNames.APP_LOGGING, new Boolean(logging));

		this.binaryServletName = getInitParameter("default-binary-servlet-name");
		if (binaryServletName != null) {
			if (getServletContext().getNamedDispatcher(binaryServletName) == null) {
				log("Binary servlet name specified, but can't be found: " + binaryServletName
						+ ". Binaries will not be served from ACM.");
			}
		}
		forwardToDefaultServlet = Boolean.valueOf(getInitParameter("forward-to-default-if-not-found", "false"))
				.booleanValue();
		this.defaultServletName = getInitParameter("default-servlet-name", "default");
		if (getServletContext().getNamedDispatcher(defaultServletName) == null) {
			forwardToDefaultServlet = false;
			this.defaultServletName = null;
		}

		String localeString = getInitParameter("defaultLocale", null);
		if (localeString != null) {
			StringTokenizer tok = new StringTokenizer(localeString, ",");
			int numTokens = tok.countTokens();
			if (numTokens == 2) {
				Locale.setDefault(new Locale(tok.nextToken(), tok.nextToken()));
			} else if (numTokens == 3) {
				Locale.setDefault(new Locale(tok.nextToken(), tok.nextToken(), tok.nextToken()));
			} else {
				log("Invalid default locale specified (" + localeString
						+ ")-  must be of form \"<language>,<country>(,<variant>)\"");
			}
		}

		String rawBypassString = getInitParameter("bypass-url-stem", null);
		if (rawBypassString != null) {
			StringTokenizer tok = new StringTokenizer(rawBypassString, ",");
			int numTokens = tok.countTokens();
			bypassStems = new String[numTokens];
			int count = 0;
			while (tok.hasMoreTokens()) {
				bypassStems[count++] = tok.nextToken();
			}
			if (logging) {
				for (int i = 0; i < bypassStems.length; i++) {
					log("Bypassing URL stem: " + bypassStems[i]);
				}
			}
		}

		// Force connection to be made now.
		try {
			ms = getMediasurface();
		} catch (com.mediasurface.client.InitException exc) {
			// Ignore - only eager loading.
		} catch (com.mediasurface.client.ConnectionException exc) {
			// Ignore - only eager loading.
		}

		String dispatcherList = getInitParameter("dispatcher-list");

		if (dispatcherList != null) {
			getServletContext().setAttribute(IAttributeNames.APP_DISPATCHER_LIST, dispatcherList);
			try {
				m_dispatchManager = new DispatcherManager(dispatcherList, "MediasurfaceControllerServlet", this,
						logging);
			} catch (ServletException se) {
				log("Unable to initialise dispatcher manager (" + se + ")");
				m_dispatchManager = null;
			}
		}

		// Load the markupedit.properties and put the props into the application context

		String markupEditList = getInitParameter("markup-edit-styles", "/WEB-INF/classes/markupedit.properties");
		java.util.Properties markupProps = new java.util.Properties();
		java.io.InputStream markupFileStream = getServletContext().getResourceAsStream(markupEditList);

		try {
			markupProps.load(markupFileStream);
			java.util.Enumeration enumer = markupProps.propertyNames();
			javax.servlet.ServletContext ctx = getServletContext();

			while (enumer.hasMoreElements()) {
				String prop = (String) enumer.nextElement();
				ctx.setAttribute("wysiwyg.style." + prop, markupProps.getProperty(prop));
			}
		} catch (Exception me) // Failure to read markup properties is a minor error, continue as normal
		{
			if (logging) {
				log("Failed to load markup edit styles: " + me);
			}
		} finally {
			try {
				markupFileStream.close();
			} catch (Exception ef) {
			}
		}

		getServletContext().setAttribute(IAttributeNames.WJ_INJECT_FILE,
				getInitParameter("wj-inject-file", "/WEB-INF/WJ/inject-code.inc"));
	}

	/**
	 * 
	 * @return
	 */
	private boolean initializeViewNameCache() {
		return true;
	}

	/**
	 * This method will determine if the supplied IItem is of a ContentReference Object type, or a subclass derived from
	 * the ContentReference Object type. The known ContentReference Object type names are held in a local member,
	 * <i>currentContentReferenceObjectTypes<\i>, for easy and quick lookup, and as new ContentReference Object type sub
	 * classes are determined, these are added to the known ContentReference Object types. By default the
	 * <i>currentContentReferenceObjectTypes<\i> has a single key entry for the base ContentReference Object type:
	 * "ContentReference"
	 * 
	 * @param checkType
	 *            The IItem for which ContentReference Object type checking will be performed.
	 * @return boolean Indicates if the supplied IItem is a ContentReference Object type or ContentReference Object type
	 *         sub class
	 */
	@SuppressWarnings({ "rawtypes", "unused" })
	private boolean isContentReferenceObjectType(IType checkType) {
		boolean isContentReferenceType = false;

		try {

			// Lookup this type's key in the currentSetOfContentReferenceObjectTypes
			if (currentContentReferenceObjectTypes.containsKey(checkType.getKey()))
				return true;

			IType parentType = checkType;
			Hashtable tempTypes = new Hashtable();

			// Check for it being a subclass of ContentReference Object Types
			do {
				// Add this parentType's name to the temporary list of ContentReference Object Types
				tempTypes.put(parentType.getKey(), "member");

				// Lookup this type in the currentSetOfContentReferenceObjectTypes
				if (currentContentReferenceObjectTypes.containsKey(parentType.getKey())) {
					isContentReferenceType = true;
					break;
				}
				parentType = parentType.getParent();
			} while (parentType.getKey() != parentType.getParent().getKey());

			// Need to add the temporary ContentReference Object Types to the currentContentReferenceObjectTypes
			if (isContentReferenceType) {
				Enumeration enumer = tempTypes.keys();
				while (enumer.hasMoreElements()) {
					String newContentReferenceType = (String) (enumer.nextElement());
					currentContentReferenceObjectTypes.put(newContentReferenceType, "member");
				}
			}
		} catch (ResourceException re) {
			// Access restricted to the ContentReference type, this should not occur, as the Type has allready been
			// accessed, and passed into this method
			// If this does occur, then return false, and declare this as an invalid ContentReference Type Object
			isContentReferenceType = false;
		} catch (AuthorizationException re) {
			// Access restricted to the ContentReference type, this should not occur, as the Type has allready been
			// accessed, and passed into this method.
			// If this does occur, then return false, and declare this as an invalid ContentReference Type Object
			isContentReferenceType = false;
		}

		return isContentReferenceType;
	}

	/**
	 * This will return the template name amended, such that the view provided becomes the final element of the template
	 * name URL, for example:<br/>
	 * <br/>
	 * templateName = /WEB-INF/templates/Article/Standard.jsp view = Edit<br/>
	 * will return<br/>
	 * /WEB-INF/templates/Article/Edit.jsp
	 * 
	 * @param destination
	 *            The templateName value to be amended
	 * @param view
	 *            The view to amend the templateName with
	 * @return The amended templateName with the view attached.
	 */

	private String amendTemplateWithView(String destination, String view) {
		if (destination.endsWith(".jsp")) {
			// should have string of the view name
			return (destination.substring(0, destination.lastIndexOf("/")) + "/" + view + ".jsp");

		} else
			// Incomplete template name, for 4.8, expect it allways to be a .jsp file
			return null;
	}

	/**
	 * 
	 * @param item
	 * @return
	 */
	private TemplateReferer getCachedTemplateReference(IItem item) {
		TemplateReferer tmpRef = new TemplateReferer();

		try {
			if (renderingTemplateReferenceCache == null) {
				if (logging)
					log("Not cacheing template record item : " + item.getSimpleName());
				// Not using the cache for any of these pages
				tmpRef.setLastUpdate(item.getUpdateDate());
				tmpRef.setPresentationTemplate(item.getFieldValue(presentationTemplateFieldName));

				// Need to do something if this is null ?
				if (tmpRef.getPresentationTemplate() == null) {
					if (logging)
						log("The " + presentationTemplateFieldName + " field, for item " + item.getSimpleName()
								+ " is null. This is invalid");
					tmpRef = null;
				}
			} else if (renderingTemplateReferenceCache.containsKey(item.getKey())) {
				// there is an entry for this Template Record item in the cache, so must check for the last
				// update time, to maintian the local cache
				tmpRef = (TemplateReferer) renderingTemplateReferenceCache.get(item.getKey());

				if (tmpRef.getLastUpdate().before(item.getUpdateDate())) {
					if (logging)
						log("Updating cache with template record item : " + item.getSimpleName());

					// The cache must be refreshed

					tmpRef.setLastUpdate(item.getUpdateDate());
					tmpRef.setPresentationTemplate(item.getFieldValue(presentationTemplateFieldName));
					// Need to do something if this is null ?

					renderingTemplateReferenceCache.put(item.getKey(), tmpRef);
				} else if (logging)
					log("Using the cached template record item : " + item.getSimpleName());

			} else {
				if (logging)
					log("Adding to the cache, template record item : " + item.getSimpleName());

				// Not currently in the cache so add it here
				tmpRef.setLastUpdate(item.getUpdateDate());
				tmpRef.setPresentationTemplate(item.getFieldValue(presentationTemplateFieldName));
				// Need to do something if the field is null ?
				if (logging)
					log("adding the template URL : " + tmpRef.getPresentationTemplate());
				renderingTemplateReferenceCache.put(item.getKey(), tmpRef);
			}
		} catch (AuthorizationException ae) {
			if (logging)
				log("getCachedTemplateReference: " + ae);
			tmpRef = null;
		} catch (ResourceException re) {
			if (logging)
				log("getCachedTemplateReference:  " + re);
			tmpRef = null;
		}
		return tmpRef;
	}

	/**
	 * This method will lookup a contained item, looking for the Link named IAttributeNames.CONTENT_RECORD_MAPPING_KEY +
	 * viewID key
	 * 
	 * @param item
	 *            the item for which contained item links will be checked
	 * @param viewID
	 *            the required view id key to lookup
	 * @return The matching contained item, or Null if it is not present.
	 */
	private IItem getContainedItemsTemplateRecord(IItem item, String viewID) throws AuthorizationException,
			ResourceException {
		IItem templateRecord = null;
		// Lookup the template request item
		try {
			templateRecord = item.getContainedItem(IAttributeNames.CONTENT_RECORD_MAPPING_KEY + viewID);
			return templateRecord;
		} catch (ContainedLinkResourceException clre) {
			if (logging)
				log("ContainedLinkResourceException: No contained link with the name "
						+ IAttributeNames.CONTENT_RECORD_MAPPING_KEY + viewID + " exists.");
			return null;
		} catch (AuthorizationException ae) {
			throw new AuthorizationException("Lookup of contained item link ("
					+ IAttributeNames.CONTENT_RECORD_MAPPING_KEY + viewID + " was not possible " + ae);
		} catch (ResourceException re) {
			throw new AuthorizationException("Lookup of contained item link ("
					+ IAttributeNames.CONTENT_RECORD_MAPPING_KEY + viewID + " was not possible " + re);
		}
	}

	/**
	 * Given an item and a requested view key, this method will determine the physical template reference that matches
	 * the given view key, from the contained links template map. The key will be used to identify which template record
	 * object will be used to provide the physical jsp template. If a successful mapping for the given key is found, the
	 * template record object will be consulted to retrieve the URL field that identifies the physical jsp template to
	 * be used for this request. If no contained item link matches the specifed view, but processing has not encountered
	 * an erroneous state, then the OLD_STYLE_TEMPLATE value will be returned, to indictae that this item should be
	 * rendered following the 4.7 style template processing.
	 * 
	 * @param req
	 *            The current HttpServletRequest object.
	 * @param item
	 *            The IItem interface of the ContentReferenceRenderer item for this request.
	 * @param view
	 *            The "view" requested in the URL to the ContentReference object. Can be null, indicating use of the
	 *            default
	 * @return The URL of the physical template reference, matching the requested view.
	 */
	private String getTemplateReference(HttpServletRequest req, IItem item, String view) {

		try {

			IItem templateRecord = getContainedItemsTemplateRecord(item, view);

			if (templateRecord == null) {
				if (logging)
					log("No template record has been found for view " + view
							+ " key, defaulting to 4.7 style <type>/<view name>.jsp processing");
				return OLD_STYLE_TEMPLATE;
			} else {
				// We have a template record for the given view
				// Look up the template reference object and should
				// now have the URL to the presentation template
				TemplateReferer lookup = getCachedTemplateReference(templateRecord);

				if (lookup == null) {
					log("The template record does not contain the expected field to a rendering jsp.");
					return null;
				}
				if (logging)
					log("The template record specifies the template : " + lookup.getPresentationTemplate());
				return lookup.getPresentationTemplate();
			}
		} catch (AuthorizationException ae) {
			if (logging)
				log("AuthorizationException in getTemplateReference : " + ae);
			return null;
		} catch (ResourceException re) {
			if (logging)
				log("ResourceException in getTemplateReference :" + re);
			return null;
		}
	}

	/**
	 * This method is used to refresh a cache object within which the view name's are keys to determine the matching
	 * view key id's. A check for the view name key within the cache is made, before refreshing the cache, in case
	 * multiple requests to this method are sequenced, and the first refresh will then have resolved all subsequent
	 * refresh requests.
	 * 
	 * @param currCache
	 *            The view name to id cache, which is to be refreshed
	 * @param view
	 *            The view name which is to be looked up within the cache
	 * @param site
	 *            The site to which this cached "view name to view key id's" applies
	 * @throws AuthorizationException
	 * @throws ResourceException
	 */
	synchronized private void refreshViewNameCache(SerializableObjectCache currCache, String view, ISite site)
			throws AuthorizationException, ResourceException {
		String viewID = null;
		String siteName = null;

		// perform another check here, as the last update may now have included the new view name
		viewID = (String) currCache.get(view);

		if (viewID == null) {
			siteName = site.getName();
			// Refresh the Cache
			IView[] allViews = site.getAllViews();

			// repopulate the Cache
			for (int i = 0; i < allViews.length;) {
				if (logging)
					log("populating view name to id cache, with view (" + allViews[i].getName() + ") and its id, "
							+ Integer.toString(allViews[i].getKey().getIntKey()));

				// Place in the viewNameCache the view name and a string representation of the view key id
				currCache.put(allViews[i].getName(), Integer.toString(allViews[i++].getKey().getIntKey()));
			}
		}
	}

	/**
	 * This method will lookup a view key id in the local cache, that matches the supplied view name. This is returned
	 * as an int representation of the view key id.
	 * 
	 * @param view
	 *            The view name determined form the request URL
	 * @param site
	 *            The site from which the current ContentReference Object item has been retrieved
	 * @return A string representation of the view key id
	 */
	private String lookupViewID(String view, ISite site) {

		String siteName = null;
		String viewID = null;

		try {
			siteName = site.getName();
			// See if the site exists within the allViewNameCaches

			SerializableObjectCache currCache = (SerializableObjectCache) allViewNameCaches.get(siteName);
			if (currCache == null) {
				// This is a new site instance so need to add it to the allViewNameCaches
				allViewNameCaches.put(siteName, new SerializableObjectCache(viewNameToIDCacheSize));
				currCache = (SerializableObjectCache) allViewNameCaches.get(siteName);

				if (logging)
					log("New site " + siteName + ", setup the viewNameCache");
			}

			viewID = (String) currCache.get(view);

			// Was it present
			if (viewID == null) {
				// No entry was found. We have determined that the view exists within the current site allready,
				// using ms.getItem(ctx, url, true); and so we must now refresh the cache to include this new
				// entry (and pick up any other changes)

				// this operation is synchronized to sequence potential multiple requests to refresh the currCache.
				refreshViewNameCache(currCache, view, site);

				// Try again to retrieve the id
				viewID = (String) currCache.get(view);
				if (viewID == null) {
					// something seriously wrong here. The view exists, but has not been populated within the
					// viewNameCache
					log("ERROR: The ms.getItem(ctx, url, true) has indicated that the view (" + view
							+ ") exists, but it has " + "not been returned from the refeshViewNameCache() method.");
					return null;
				}
			}
		} catch (AuthorizationException ae) {
			log("AuthorizationException: during lookup of view " + view + " from the site (" + siteName + ") : " + ae);
		} catch (ResourceException re) {
			log("ResourceException: during lookup of view " + view + " from the site (" + siteName + ") : " + re);
		}

		if (logging)
			log("Found " + view + " in the viewNameCache with id " + viewID);

		return viewID;
	}

	/**
	 * Returns the rendering tempate (.jsp) that should be used to facilitate the presentation for this item request.<br/>
	 * <br/>
	 * default template naming rules:<br/>
	 * <br/>
	 * 1) Determine the view key id: If no view key is found, error and return null<br/>
	 * 2) Determine the template reference / URL used to present the requested item: If no template reference is found,
	 * use the old 4.7 <type>/<view>.jsp template mapping<br/>
	 * 3) Return the template reference.<br/>
	 * It is expected that the value null returned from this method should result in a 404 exception.
	 * 
	 * @param req
	 *            The current HttpServletRequest object.
	 * @param res
	 *            The current HttpServletResponse object.
	 * @param item
	 *            The IItem interface of the ContentReference item of this request.
	 * @param view
	 *            The "view" that has been set for this request.
	 * @return String The URL location of the rendering template file used for the presentation of the response. May be
	 *         null, to indicate that there has been a fault in determining the correct template to use for this request
	 */
	private String getRenderingTemplate(HttpServletRequest req, HttpServletResponse res, IItem item, String view)
			throws ServletException {
		try {

			// if a template id is specified as a param then we can
			// use this directly.
			String templateId = req.getParameter(TEMPLATE_ID_PARAM);
			if (templateId != null) {
				try {
					Mediasurface ms = getMediasurface();
					SecurityContextHandle ctx = MediasurfaceControllerServlet.getSecurityContext(req, ms);

					IItem templateItem = ms.getItem(ctx, new ItemKey(Integer.parseInt(templateId)));
					return templateItem.getFieldValue(presentationTemplateFieldName);
				}

				catch (com.mediasurface.client.InitException exc) {
					// Ignore - only eager loading.
				} catch (com.mediasurface.client.ConnectionException exc) {
					// Ignore - only eager loading.
				}
			}

			// Look up the cached view key id from the view name determined in the URL request.
			String viewID = lookupViewID(view, item.getSite());

			if (viewID == null) {
				// We have no match between the view name and a view key id in the current cache
				// Log the error, and return null to indicate that no template record could be found
				if (logging) {
					log("There is no view with the name " + view + ", located within the ViewName cache. ");
				}
				return null;
			}

			// Determine the physical template used to render the requested item
			String destination = getTemplateReference(req, item, viewID);

			if (destination == OLD_STYLE_TEMPLATE) {
				if (logging) {
					log("No rendering template record entry has been determined for the requested item ( "
							+ item.getFullName()
							+ " ). Defaulting to use the old 4.7 <type>/<view>.jsp template mapping");
				}
			} else if (destination == null) {
				log("Error processing the template record entry for the requested item ( " + item.getFullName() + " )");
				return null;
			}

			// place the requested item in the req context, overriding the requested ContentReferenceRenderer item
			// that has been placed there allready, and place the ContentReferenceRenderer in the request.
			req.setAttribute(IAttributeNames.ITEM, item);

			// Check to see if we must support old style (4.7) processing
			if (destination.equals(OLD_STYLE_TEMPLATE))
				try {
					destination = getCascadePath(item.getType().getName(), view, getRequestGroup(req));
				} catch (java.net.MalformedURLException murle) {
					throw new javax.servlet.ServletException(murle.getMessage(), murle);
				}
			return destination;
		} catch (AuthorizationException ae) {
			if (logging) {
				log("AuthorizationException: " + toString());
			}
			return null;
		} catch (ResourceException re) {
			if (logging) {
				log("ResourceException: " + re.toString());
			}
			return null;
		}
	}

	/**
	 * Read Servlet intialization parameter, with default.
	 * 
	 * @param name
	 *            Name of parameter.
	 * @param defaultValue
	 *            Value to return if parameter not present
	 * @return Parameter value or default if not present. May only be null if defaultValue is too.
	 */
	private String getInitParameter(String name, String defaultValue) {
		String value = getInitParameter(name);
		return value == null ? defaultValue : value;
	}

	private String getOutputFromWJServer(URL wjUrl) {
		String retVal = null;

		try {
			URLConnection urlConnection = wjUrl.openConnection();
			HttpURLConnection http = (HttpURLConnection) urlConnection;
			http.connect();

			InputStream in = new BufferedInputStream(http.getInputStream());
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			byte[] buf = new byte[1024];
			int n = 0;
			while (-1 != (n = in.read(buf))) {

				out.write(buf, 0, n);
			}
			out.close();
			in.close();
			retVal = out.toString();
		} catch (IOException e) {
			if (logging) {
				log("Unable to read output stream from Web journey server" + e.getMessage());
			}
		}

		return retVal;
	}

	// 1. Check if the WJ server token is available
	// 3. If not available then get it by making request to WJ server
	// 4. Otherwise check if the token is valid or not
	// 5. If not valid then get the token again
	private String checkAndGetWJToken(SecurityContextHandle ctx, HttpServletRequest req, HttpServletResponse res,
			Mediasurface ms) {
		URL wjUrl;
		String wjUserName;
		String wjPassword;
		String wjDBName;
		String wjProxyUrl = null;
		String wjAuth;
		String wjToken = null;
		com.mediasurface.client.IHost host = null;

		try {
			host = ms.getHost(ctx, req.getServerName() + ":" + req.getServerPort());
			wjToken = wjTokens.get(host.getKey());

			wjProxyUrl = host.getProperty("wjproxyurl");
			wjProxyUrl = wjProxyUrl.endsWith("/") ? wjProxyUrl : wjProxyUrl + "/";

			if (wjToken == null) {
				wjUserName = host.getProperty("wjusername");
				wjPassword = host.getProperty("wjpassword");
				wjDBName = host.getProperty("wjdbname");
				wjAuth = Base64.encodeString(wjUserName + ":" + wjPassword);
				wjUrl = new URL(wjProxyUrl + "getToken?auth=" + wjAuth + "&catalog=" + wjDBName + "&callback=foo");

				wjToken = getOutputFromWJServer(wjUrl);
				wjToken = (wjToken != null ? wjToken.substring(5, wjToken.length() - 3) : wjToken);
				wjTokens.put(host.getKey(), wjToken);
			} else {
				// check token is valid or not
				wjUrl = new URL(wjProxyUrl + "isTokenValid?token=" + wjToken + "&callback=foo");
				String isTokenValid = getOutputFromWJServer(wjUrl);
				isTokenValid = (isTokenValid != null ? isTokenValid.substring(4, isTokenValid.length() - 2)
						: isTokenValid);

				if (isTokenValid == null || isTokenValid.equalsIgnoreCase("false")) {
					wjUserName = host.getProperty("wjusername");
					wjPassword = host.getProperty("wjpassword");
					wjDBName = host.getProperty("wjdbname");
					wjAuth = Base64.encodeString(wjUserName + ":" + wjPassword);
					wjUrl = new URL(wjProxyUrl + "getToken?auth=" + wjAuth + "&catalog=" + wjDBName + "&callback=foo");
					wjToken = getOutputFromWJServer(wjUrl);
					wjToken = (wjToken != null ? wjToken.substring(5, wjToken.length() - 3) : wjToken);
					wjTokens.put(host.getKey(), wjToken);
				}
			}
		} catch (Exception e) {
			if (logging) {
				log("Unable to get and check WJ token " + e.getMessage());
			}
			try {
				res.sendError(HttpServletResponse.SC_NON_AUTHORITATIVE_INFORMATION);
			} catch (Exception ex) {
			}
		}

		return wjToken;
	}

	@Override
	protected void service(HttpServletRequest req, HttpServletResponse res) throws javax.servlet.ServletException,
			java.io.IOException {
		try {
			// Get stuff from request/session/application.
			final Mediasurface ms = getMediasurface();
			SecurityContextHandle ctx = MediasurfaceControllerServlet.getSecurityContext(req, ms);
			IHost host = ms.getHost(ctx, req.getServerName() + ":" + req.getServerPort());
			req.setAttribute("requestItemHost", host);
			// Set the request encoding (if requested in web.xml)
			if (requestEncoding != null) {
				req.setCharacterEncoding(requestEncoding);
			}

			IType type = null;
			IItem item = null;
			final String path = getUrlPath(req, false);
			javax.servlet.RequestDispatcher dispatcher = null;

			IDispatcher localDispatcher = null;
			if (m_dispatchManager != null)
				localDispatcher = m_dispatchManager.getMappedDispatcher(path);

			if (((m_dispatchManager != null)) && (localDispatcher != null)) {
				final String view = getRequestView(req);
				if (logging) {
					log("View retrieved is " + view + ", from path " + path + " (template separator : "
							+ templateSeparator + ")");
				}
				java.util.StringTokenizer st = new java.util.StringTokenizer(path, templateSeparator);
				st.nextToken(); // skip the model prefix part of the URL...

				String stringType;
				try {
					stringType = st.nextToken();
				} catch (java.util.NoSuchElementException exc) {
					stringType = null;
				}
				if ((stringType == null) || (stringType.startsWith("?"))) {
					stringType = null;
				} else if (logging) {
					log("Model Forward : setting " + IAttributeNames.TYPEID + " to " + stringType);
				}

				String stringItemID;
				try {
					stringItemID = st.nextToken();
				} catch (java.util.NoSuchElementException exc) {
					stringItemID = null;
				}
				if ((stringItemID == null) || (stringItemID.startsWith("?"))) {
					stringItemID = null;
				} else if (logging) {
					log("Model Forward : setting " + IAttributeNames.ITEMID + " to " + stringItemID);
				}
				Utils.setContextItem(req, stringType, stringItemID);

				req.setAttribute(IAttributeNames.VIEW, view);
				if (logging) {
					log("Model Forward : setting " + IAttributeNames.VIEW + " to " + view);
				}

				req.setAttribute(IAttributeNames.VERSION, getRequestVersion(req));
				if (logging) {
					log("Model Forward : setting " + IAttributeNames.VERSION + " to " + getRequestVersion(req));
				}

				req.setAttribute(IAttributeNames.GROUP, getRequestGroup(req));
				if (logging) {
					log("Model Forward : setting " + IAttributeNames.GROUP + " to " + getRequestGroup(req));
				}

				if (logging) {
					log("Forwarding request to IDispatcher: " + localDispatcher.getName());
				}

				localDispatcher.processRequest(req, res);
			} else {
				if (bypassStems != null) {
					for (int i = 0; i < bypassStems.length; i++) {
						if (path.startsWith(bypassStems[i])) {
							if (logging) {
								log("Bypassing request. Path (" + path + ") matches a bypass stem");
							}
							if (this.defaultServletName != null) {
								getServletContext().getNamedDispatcher(this.defaultServletName).forward(req, res);
							}
							return;
						}
					}
				}

				// Handle InSitu Mode Headers
				String inSituMode = null;

				if ((inSituMode = req.getHeader(IAttributeNames.IN_SITU_EDITING)) != null
						|| (inSituMode = req.getParameter(IAttributeNames.IN_SITU_EDITING)) != null) {
					req.setAttribute(IAttributeNames.IN_SITU_EDITING, inSituMode);

					if (ctx != null) {
						ms.setAdminMode(ctx, true);
					}
				}

				// Query for the resolve links URL parameter
				String resolveLinksFlag = null;
				if ((resolveLinksFlag = req.getParameter(IAttributeNames.RESOLVE_LINKS)) != null) {
					req.setAttribute(IAttributeNames.RESOLVE_LINKS, resolveLinksFlag);
				}

				// doing stuff for WebJourney server token
				// 1. Check if the WJ analytics page view is requested or not
				// 2. If requested then get the token and add the token to the url and redirect the url.
				String viewWebAnalytics = getRequestViewWebAnalytics(req);
				if (viewWebAnalytics != null && viewWebAnalytics.toLowerCase().equals("true")) {
					String wjToken = checkAndGetWJToken(ctx, req, res, ms);
					if (wjToken != null) {
						String reqUrl = getUrlPath(req, true) + "?" + TOKEN_PARAM + "=" + wjToken;
						res.sendRedirect(reqUrl);
						return;
					}
				}

				final String url = getItemUrl(req);
				try {
					item = ms.getItem(ctx, url, true);
				} catch (com.mediasurface.general.ViewNotFoundException vexc) {
					if (logging) {
						log("View not found for item with URL " + url + " (" + vexc.getMessage() + ")");
					}
					// res.sendError(HttpServletResponse.SC_NOT_FOUND); // 404
					notFound(req, res, url);
					return;
				} catch (com.mediasurface.general.ResourceException exc) {

					String newurl;
					int index = url.indexOf('?');

					if (url.charAt(url.length() - 1) != '/' || (index != -1 && url.charAt(index - 1) != '/')) {
						if (index == -1)
							newurl = "http:" + url + "/";
						else {
							newurl = "http:" + url.substring(0, index) + "/" + url.substring(index);
						}

						try {
							IItem item2 = ms.getItem(ctx, newurl, true);
							res.sendRedirect(newurl);
							return;
						} catch (Exception e) {
						} // Ignore exceptions
					}
					if (forwardToDefaultServlet) {
						if (logging) {
							log("Forwarding request for " + url + " to default servlet");
						}
						getServletContext().getNamedDispatcher(this.defaultServletName).forward(req, res);
					} else {
						if (logging) {
							log("Unable to find item with URL " + url + " (" + exc + ")");
						}
						// res.sendError(HttpServletResponse.SC_NOT_FOUND); // 404
						notFound(req, res, url);
					}
					return;
				}
				if (logging) {
					log("Processing request for item with URL " + url);
				}

				// At this point, we have a valid item request, that is not part of the cmc (didnt use a Dispatcher from
				// the
				// m_dispatchManager factory) so, we will assume that it may now be a 4.7 item request, or potentially
				// a 4.8 ContentReference request.

				type = item.getType();

				req.setAttribute(IAttributeNames.ITEM, item);
				req.setAttribute(IAttributeNames.TYPE, type);

				// Find the "view" for which the request was made
				String reqView = getRequestView(req);

				// Should check here if the "view" is null, if so return the default view
				if (reqView == null || reqView == "")
					reqView = getDefaultView(item);

				// Check for a named binary servlet or mapped by Content Reference + (type and view).
				if (binaryServletName != null && type.isBinary()
						&& (reqView == null || reqView.equals(getDefaultView(item)))) {
					// Binary servlet present,
					// item is binary
					// and default view.
					dispatcher = getServletContext().getNamedDispatcher(binaryServletName);
					if (logging) {
						log("Forwarding request to binary servlet");
					}
				} else {
					// The requested item, will be placed into the request context as "requestItem" and if
					// it is of type (or subtype) ContentReference its internal representation of the
					// ContentReference item and associated content item will be handled through the API.
					// This means we do not have to worry about checking if the requested item is of a
					// type (or subtype) of Content Reference

					String templateRendererPath = getRenderingTemplate(req, res, item, reqView);

					if (templateRendererPath != null)
						dispatcher = req.getRequestDispatcher(templateRendererPath);
					else {
						if (logging) {
							log("No template determined for rendering this request object");
						}
						// Send a 404 error error
						// res.sendError(404,
						// "No Template can be found to render the requested item, " + item.getFullName());
						notFound(req, res, url);
						return;
					}
					if (logging) {
						log("The Forwarding path for the rendering template is: " + templateRendererPath);
					}
				}
				// Should now have the destination used to render the item / request.
				dispatcher.forward(req, res);
			}
		} catch (SecurityContextNotFoundException ex) {
			// In this case, the security context handle must be invalid.
			// Remove it from the session, and return a 404 requesting
			// authentication credentials...
			removeSessionSecurityContext(req);
			unauthorized(req, res, ex);
		} catch (com.mediasurface.general.AuthorizationException exc) {
			unauthorized(req, res, exc);
		} catch (javax.servlet.ServletException exc) {
			// Check wrapped and then chained exceptions.
			Throwable rootCause = exc.getRootCause();
			if (rootCause instanceof AuthorizationException) {
				// Sevlet wrapped authorization issue.
				unauthorized(req, res, (AuthorizationException) rootCause);
			} else if (rootCause instanceof IChainedException) {
				Throwable rootRootCause = ((IChainedException) rootCause).getRootCause();
				if (rootRootCause instanceof AuthorizationException) {
					// Sevlet wrapped and chained authorization issue.
					unauthorized(req, res, (AuthorizationException) rootRootCause);
				} else {
					// Sevlet wrapped and chained non-authorization issue
					// - rethrow.
					throw exc;
				}
			} else {
				// Sevlet wrapped non-authorization issue - rethrow.
				throw exc;
			}
		} catch (com.mediasurface.client.InitException exc) {
			throw new javax.servlet.ServletException(exc.getMessage(), exc);
		} catch (com.mediasurface.client.ConnectionException exc) {
			throw new javax.servlet.ServletException(exc.getMessage(), exc);
		} catch (com.mediasurface.general.ResourceException exc) {
			throw new javax.servlet.ServletException(exc.getMessage(), exc);
		} catch (java.net.MalformedURLException exc) {
			throw new javax.servlet.ServletException(exc.getMessage(), exc);
		} finally {
			if (requestsLeftBeforeViewReload > 0) {
				--requestsLeftBeforeViewReload;
			}
		}
	}

	/**
	 * Handle attempt at unauthorized access. Should attempt to get the user to log in.
	 */
	protected void unauthorized(HttpServletRequest req, HttpServletResponse res, AuthorizationException excep // For
																											// logging
																											// output
																											// only
	) throws java.io.IOException {
		if (logging) {
			log("Not authorized for " + getItemUrl(req) + ": " + excep.toString());
		}
		// Only challenge if we don't already have
		// a security context handle on the session.
		if (getSessionSecurityContext(req) == null) {
			try {
				String hostName = req.getServerName();
				Mediasurface ms = getMediasurface();
				com.mediasurface.client.IHost thisHost = ms.getHost(null, hostName + ":" + req.getServerPort());
				if (thisHost.getSite().getAuthenticationMethod() != com.mediasurface.datatypes.BasicSiteData.AUTH_NONE) {
					res.setHeader("WWW-Authenticate", "Basic realm=\"" + authenticateRealm + '\"');
				}
			} catch (Exception e) {
				log("An exception occured when getting the host for " + getItemUrl(req) + ": " + e.toString());
				// Do nothing;
			}
		}
		// 401 Unauthorized
		res.sendError(HttpServletResponse.SC_UNAUTHORIZED);
	}

	/*
	 * Check for the connection status and return false in case of any exception.
	 */
	private boolean checkConnection(Mediasurface ms) {
		boolean connectionStatus = false;

		try {
			connectionStatus = ms.isConnected();
		} catch (Throwable th) {
			if (logging) {
				log("Error checking server connection status." + th.getMessage() + " Returning false");

			}
			connectionStatus = false;
		}

		return connectionStatus;
	}

	/**
	 * Returns "ms" Mediasurface from application/servlet context or creates new. If required to create a new
	 * Mediasurface, places back into context. Never null.
	 */

	private Mediasurface getMediasurface() throws com.mediasurface.client.InitException,
			com.mediasurface.client.ConnectionException, ServletException {
		// Get Mediasurface.
		final Object msObj = getMediasurfaceObject();

		if ((msObj instanceof Mediasurface)) {
			// Nothing needs doing.
			if (checkConnection((Mediasurface) msObj)) {
				return (Mediasurface) msObj;
			}
		}

		// Looks like we may need to recreate.
		String mediasurfaceUrl = getInitParameter("mediasurface-url");
		String serverName = getInitParameter("server-name");
		int serverPort = 0;
		try {
			if (serverName != null) {
				serverPort = Integer.parseInt(getInitParameter("server-port", "8080"));
			}
		} catch (NumberFormatException ex) {
			if (logging) {
				log("Invalid port number specified for server-port parameter");
			}
			serverName = null;
		}
		synchronized (MaeUtils.m_mediasurfaceApplicationLock) {
			final Object msObjRecheck = getMediasurfaceObject();
			if (msObjRecheck instanceof Mediasurface) {
				if (checkConnection((Mediasurface) msObjRecheck)) {
					// We now do have a Mediasurface - good job we checked.
					return (Mediasurface) msObjRecheck;
				}
			}
			// Create and initalise.
			String factoryClass = null;
			if (useContainerContextFactory) {
				factoryClass = System.getProperty("java.naming.factory.initial");
			}

			final Mediasurface ms = createMediasurfaceObject(mediasurfaceUrl, serverName, serverPort, factoryClass);

			checkLicenceKey(ms);
			// If licence key check fails, exception thrown back up and next line not reached

			// Put back into application/servlet context.
			final javax.servlet.ServletContext context = getServletContext();
			context.setAttribute(MaeUtils.MEDIASURFACE_NAME, ms);

			// Return newly created object.
			return ms;
		}
	}

	protected Mediasurface createMediasurfaceObject(String mediasurfaceUrl, String serverName, int serverPort,
			String factoryClass) throws com.mediasurface.client.InitException,
			com.mediasurface.client.ConnectionException {
		final Mediasurface ms = new Mediasurface();
		mediasurfaceUrl = (mediasurfaceUrl == null || "".equals(mediasurfaceUrl)) ? "//localhost/" : mediasurfaceUrl;

		if (serverName == null) {
			ms.init(mediasurfaceUrl, factoryClass);
		} else {
			ms.init(mediasurfaceUrl, serverName, serverPort, factoryClass);
		}

		return ms;
	}

	/**
	 * Check licence key. Throws a ServletException if licence key doesn't support this module.
	 */
	private void checkLicenceKey(Mediasurface ms) throws ServletException {
		// Check licence key for access to Java Delivery Framework module
		if (logging) {
			log("Checking module access...");
		}
		try {
			if (ms.hasModuleAccess(IProductModule.JAVA_DELIVERY_FRAMEWORK)) {
				if (logging) {
					log("...licence key OK");
				}
			} else {
				if (logging) {
					log("Licence key does not permit use of Java Delivery Framework");
				}
				throw (new ServletException("Licence key does not permit use of Java Delivery Framework"));
			}
		} catch (ResourceException e) {
			// Always fail if can't check licence key
			throw new ServletException(e);
		}
	}

	/**
	 * Returns "ms" Mediasurface object from application/servlet context. May be null.
	 */
	private Object getMediasurfaceObject() {
		final javax.servlet.ServletContext context = getServletContext();
		return context.getAttribute(MaeUtils.MEDIASURFACE_NAME);
	}

	/**
	 * Returns the appropriate SecurityContextHandle. Will first attempt to use the "ctx" SecurityContextHandle from
	 * session context. If that fails, it will create one for the login specified by Basic HTTP authentication.
	 * 
	 * May return null (i.e. public user).
	 */
	@SuppressWarnings("deprecation")
	public static SecurityContextHandle getSecurityContext(HttpServletRequest req, final Mediasurface ms) {
		// Session (from login).
		{
			SecurityContextHandle ctx = MediasurfaceControllerServlet.getSessionSecurityContext(req);

			if (ctx != null) {
				return ctx;
			}
		}

		// HTTP Basic login.
		{
			SecurityContextHandle ctx = getHttpSecurityContext(req, ms);

			if (ctx != null) {
				// Save handle in the session
				javax.servlet.http.HttpSession session = req.getSession(true);

				if (session != null) {
					session.setAttribute(MaeUtils.SECURITY_NAME, ctx);
					// Add object that will log out of the CAe when the session expires
					final String attrName = "_msTaglibTimeoutHandler";
					// Must not replace the attribute, as then the old one will
					// be removed before the session has timed out
					if (session.getAttribute(attrName) == null) {
						session.setAttribute(attrName, new SessionTimeoutHandler(ctx));
					}
				}

				return ctx;
			}
		}

		String ctxStr = req.getParameter(MaeUtils.SECURITY_NAME);
		if (ctxStr != null) {
			try {
				SecurityContextHandle ctx = SecurityContextHandle.fromString(ctxStr);
				javax.servlet.http.HttpSession session = req.getSession(true);
				session.setAttribute(MaeUtils.SECURITY_NAME, ctx);
				return ctx;
			} catch (Exception e) {
				return null;
			}
		}

		// To Do : For the time being kept like this. Probably after licensing project we don't need the below codes.
		String useridPassword = req.getParameter("Cred");

		if (useridPassword != null) {
			useridPassword = new String(com.mediasurface.general.Base64.decode(useridPassword), 0);
			useridPassword = useridPassword.trim();

			int colon = useridPassword.indexOf(':');

			if (colon == -1 || colon == 0 || colon == useridPassword.length() - 1) {
				// We need a username and a password - ignore.
				return null;
			}

			String msUserName = useridPassword.substring(0, colon);
			String msPassword = useridPassword.substring(colon + 1);

			if (msUserName != null && msPassword != null) {
				try {
					SecurityContextHandle ctx = ms.secureLogin(msUserName, msPassword);
					if (ctx != null) {
						// Save handle in the session
						javax.servlet.http.HttpSession session = req.getSession(true);
						if (session != null) {
							session.setAttribute(MaeUtils.SECURITY_NAME, ctx);
							// Add object that will log out of the CAe when the session expires
							final String attrName = "_msTaglibTimeoutHandler";
							// Must not replace the attribute, as then the old one will
							// be removed before the session has timed out
							if (session.getAttribute(attrName) == null) {
								session.setAttribute(attrName, new SessionTimeoutHandler(ctx));
							}
						}
						return ctx;
					}
				} catch (com.mediasurface.general.AuthenticationException exc) {
					// Failed to login - ignore.
					return null;
				} catch (com.mediasurface.general.ResourceException exc) {
					// Ignore.
					return null;
				}
			}
		}

		// Not logged in.
		return null;
	}

	/**
	 * Returns a SecurityContextHandle for the login specified by Basic HTTP authentication. Does not modify the request
	 * context. May be null (i.e. public user). This can mean authentication failed for some reason If a header named
	 * 'Offline' and valued 'true' is found then log the user in in Offline Mode.
	 */
	private static final String BASIC_PREFIX = "Basic ";

	private static SecurityContextHandle getHttpSecurityContext(HttpServletRequest req, final Mediasurface ms) {
		// Get details.
		String authorization = req.getHeader("Authorization");

		// See if anything there.
		if (authorization == null) {
			// Not even attempted.
			return null;
		}

		// Check authentication method is Basic.
		if (!authorization.startsWith(BASIC_PREFIX)) {
			// Don't understand authentication method - will not do.
			return null;
		}

		// Handle basic authentication.
		String basicCookie = authorization.substring(BASIC_PREFIX.length());
		String useridPassword = new String(com.mediasurface.general.Base64.decode(basicCookie));

		// It is possible that this decoded string will have a space character at the beginning.
		// This is due to a workaround needed for the IE control used by ACM which has difficulty
		// correctly demarcating HTTP headers.
		// Strip whitespace off.
		useridPassword = useridPassword.trim();

		// Split userid:password
		int colon = useridPassword.indexOf(':');

		if (colon == -1 || colon == 0 || colon == useridPassword.length() - 1) {
			// We need a username and a password - ignore.
			return null;
		}

		String userid = useridPassword.substring(0, colon);
		String password = useridPassword.substring(colon + 1);

		// Check for the presence of a Offline header
		String offline = req.getHeader("Offline");

		// Actually login and store in request.
		try {
			if (offline == null || !offline.equals("true")) {
				SecurityContextHandle ctx = ms.secureLogin(userid, password);
				return ctx;
			} else {
				SecurityContextHandle ctx = ms.secureLogin(userid, password, true);
				return ctx;
			}
		} catch (com.mediasurface.general.AuthenticationException exc) {
			// Failed to login - ignore.
			return null;
		} catch (com.mediasurface.general.ResourceException exc) {
			// Ignore.
			return null;
		}
	}

	/**
	 * Returns "ctx" SecurityContextHandle from session context. Never creates new context. May be null (i.e. public
	 * user).
	 */
	private static SecurityContextHandle getSessionSecurityContext(HttpServletRequest req) {
		// Get session if exists.
		javax.servlet.http.HttpSession session = req.getSession(false);

		if (session == null) {
			// No session - public user.
			return null;
		} else {
			Object ctxObj = session.getAttribute(MaeUtils.SECURITY_NAME);

			if (ctxObj instanceof SecurityContextHandle) {
				// A real, logged in user.
				return (SecurityContextHandle) ctxObj;
			} else {
				// Not of correct type (!) - public user.
				// Quite possible a ClassLoader issue.
				return null;
			}
		}
	}

	protected void removeSessionSecurityContext(HttpServletRequest req) {
		// Get session if exists.
		javax.servlet.http.HttpSession session = req.getSession(false);
		if (session != null) {
			session.removeAttribute(MaeUtils.SECURITY_NAME);
		}
	}

	/**
	 * Returns URL for <strong>Mediasurface</strong> Item from request.
	 */
	private String getItemUrl(HttpServletRequest req) {
		final String path = getUrlPath(req, true);
		final String version = getRequestVersion(req);
		final String view = getRequestView(req);
		final String host = req.getServerName();
		final int port = req.getServerPort();
		return "//" + host + ':' + port + path + (version == null ? "" : ('?' + VERSION_PARAM + '=' + version))
				+ (view == null ? "" : (version == null ? "?" : "&") + (VIEW_PARAM + '=' + view));
	}

	/**
	 * Returns path sent in request URL.
	 */
	private String getUrlPath(HttpServletRequest req, boolean useContext) {

		/*
		 * Lets assume for the moment we allways want the full path with any context left in tact
		 */
		String context = "";

		if (useContext) {
			context = req.getContextPath();
			context = (context == null) ? "" : context;
		}

		// Default servlets (/ mapping) have
		// entire path after web application path in servletPath
		// and null pathInfo.
		// Path mapped servlets (/x/*) have
		// /x/ in servletPath and rest in pathInfo.
		// Therefore, if pathInfo present use it, otherwise use servletPath.

		String servletPath = req.getServletPath();
		servletPath = (servletPath == null) ? "" : servletPath;

		String pathInfo = req.getPathInfo();

		if (pathInfo == null) {
			pathInfo = context + servletPath;
		} else {
			pathInfo = context + servletPath + pathInfo;
		}

		if (logging) {
			log("Request Path to use: " + pathInfo);
		}

		return pathInfo;

	}

	/**
	 * Returns path to jsp which is to be used to display this resource. It follows the application model defaulting
	 * method
	 */
	private String getCascadePath(String typeName, String view, String grp) throws java.net.MalformedURLException {
		String testPath;
		java.io.InputStream is;
		if (grp != null) {
			// Try for the group specific type based JSP
			testPath = templateBase + NameEncoder.encode(typeName) + templateSeparator + NameEncoder.encode(grp)
					+ templateGroupSeparator + NameEncoder.encode(view) + templateExtension;
			if (isFileAvailable(testPath)) {
				return testPath;
			}
		}

		// Try for the type based JSP
		return templateBase + NameEncoder.encode(typeName) + templateSeparator + NameEncoder.encode(view)
				+ templateExtension;
	}

	private boolean isFileAvailable(String testPath) throws java.net.MalformedURLException {
		String method = "testPath";
		if (getServletContext().getResource(testPath) != null) {
			return true;
		}
		return false;
	}

	/**
	 * Gets the view-web-analytic parameter from the request. Due to a bug in ATG Dynamo, the view-web-analytic
	 * parameter is not available via HttpServletRequest.getParameter if it was part of the "action" attribute of the
	 * form, rather than a form input.
	 */
	private String getRequestViewWebAnalytics(HttpServletRequest req) {
		return req.getParameter(VIEW_WEB_ANALYTICS_PARAM);

		// if (IN_DYNAMO
		// && viewWebAnalytics == null
		// && req instanceof atg.servlet.DynamoHttpServletRequest)
		// {
		// return (
		// (atg.servlet.DynamoHttpServletRequest) req).getQueryParameter(
		// viewWebAnalytics);
		// }
		// else
		// {
		// return viewWebAnalytics;
		// }
	}

	/**
	 * Gets the view parameter from the request. Due to a bug in ATG Dynamo, the view parameter is not available via
	 * HttpServletRequest.getParameter if it was part of the "action" attribute of the form, rather than a form input.
	 */
	private String getRequestView(HttpServletRequest req) {
		return req.getParameter(VIEW_PARAM);
		// if (IN_DYNAMO
		// && view == null
		// && req instanceof atg.servlet.DynamoHttpServletRequest)
		// {
		// return (
		// (atg.servlet.DynamoHttpServletRequest) req).getQueryParameter(
		// VIEW_PARAM);
		// }
		// else
		// {
		// return view;
		// }
	}

	/**
	 * Gets the version parameter from the request. Due to a bug in ATG Dynamo, the version parameter is not available
	 * via HttpServletRequest.getParameter if it was part of the "action" attribute of the form, rather than a form
	 * input.
	 */
	private String getRequestVersion(HttpServletRequest req) {
		return req.getParameter(VERSION_PARAM);
		// if (IN_DYNAMO
		// && version == null
		// && req instanceof atg.servlet.DynamoHttpServletRequest)
		// {
		// return (
		// (atg.servlet.DynamoHttpServletRequest) req).getQueryParameter(
		// VERSION_PARAM);
		// }
		// else
		// {
		// return version;
		// }
	}

	/**
	 * Gets the group parameter from the request. Due to a bug in ATG Dynamo, the group parameter is not available via
	 * HttpServletRequest.getParameter if it was part of the "action" attribute of the form, rather than a form input.
	 */
	private String getRequestGroup(HttpServletRequest req) {
		return req.getParameter(GROUP_PARAM);
		// if (IN_DYNAMO
		// && grp == null
		// && req instanceof atg.servlet.DynamoHttpServletRequest)
		// {
		// return (
		// (atg.servlet.DynamoHttpServletRequest) req).getQueryParameter(
		// GROUP_PARAM);
		// }
		// else
		// {
		// return grp;
		// }
	}

	/**
	 * Returns the name of the default view for an item (actually the default view for the item's site). Never null,
	 * defaulting to "Standard".
	 * 
	 * @param item
	 *            Item belonging to site to get default view for.
	 */
	private String getDefaultView(IItem item) throws com.mediasurface.general.AuthorizationException,
			com.mediasurface.general.ResourceException {
		if (defaultViewName == null || requestsLeftBeforeViewReload == 0) {
			boolean found = false;
			requestsLeftBeforeViewReload = REQUESTS_BETWEEN_VIEW_RELOADS;
			com.mediasurface.client.ISite site = item.getSite();
			com.mediasurface.datatypes.ViewKey defaultKey = site.getDefaultViewKey();
			if (defaultKey != null) {
				com.mediasurface.datatypes.ViewData[] views = site.getViews();
				final int num = views.length;
				for (int ct = 0; ct < num; ++ct) {
					com.mediasurface.datatypes.ViewData view = views[ct];
					if (defaultKey.equals(view.getKey())) {
						// Found it.
						defaultViewName = view.getName();
						found = true;
					}
				}
			}

			if (!found) {
				// Not found!
				defaultViewName = "Standard";
			}
		}
		return defaultViewName;
	}

	class TemplateReferer implements Serializable {
		private Date lastUpdate;
		public String presentationTemplate = "";

		/**
		 * @return
		 */
		public Date getLastUpdate() {
			return lastUpdate;
		}

		/**
		 * @param date
		 */
		public void setLastUpdate(Date date) {
			lastUpdate = date;
		}

		/**
		 * @return
		 */
		public String getPresentationTemplate() {
			return presentationTemplate;
		}

		/**
		 * @param string
		 */
		public void setPresentationTemplate(String string) {
			presentationTemplate = string;
		}
	}

	protected void notFound(HttpServletRequest req, HttpServletResponse res, String url) throws IOException {
		res.sendError(HttpServletResponse.SC_NOT_FOUND);
	}

}
